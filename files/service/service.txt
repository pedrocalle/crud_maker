import { Repository, getRepository } from 'typeorm';
import AppError from '@/shared/errors/AppError';
import { InferType } from 'yup';
import { BasicQueryFilters } from '@/shared/models';
import { toConditionQueryBuilder } from '@/utils';
import { uModuleName } from '../entities/module_name.entity';
import { CreateuModuleName, UpdateuModuleName } from '../validators/uModuleNameValidator';

type TCreateuModuleName = InferType<typeof CreateuModuleName>;
type TUpdateuModuleName = InferType<typeof UpdateuModuleName> &
  Partial<TCreateuModuleName>;

class uModuleNameService {
  moduleNameRepo: Repository<uModuleName>;

  constructor() {
    this.moduleNameRepo = getRepository(uModuleName);
  }

  public async create(body: TCreateuModuleName) {
    const moduleNameExists = await this.moduleNameRepo.findOne({
      where: {
        code: body.code,
      },
    });

    if (moduleNameExists) {
      throw new AppError('uModuleName já existe');
    }

    const newuModuleName = this.moduleNameRepo.create(body);

    await this.moduleNameRepo.save(newuModuleName);

    return newuModuleName;
  }

  public async read({fields, sort, rows, page}: Partial<BasicQueryFilters>) {
    
    const { whereQuery, whereValues, orderBy } = toConditionQueryBuilder({
      fields,
      sort,
    });

    const [results, total_results] = await this.moduleNameRepo
      .createQueryBuilder('entity')
      .where(whereQuery, whereValues)
      .skip(rows * (page - 1))
      .take(rows)
      .orderBy(orderBy)
      .getManyAndCount();
    
    return { results, total_results };
  }

  public async update({ id, ...body }: TUpdateuModuleName) {
    const moduleName = await this.moduleNameRepo.findOne({
      where: { id },
    });

    if (!moduleName) {
      throw new AppError('uModuleName não encontrado');
    }

    const merge = this.moduleNameRepo.merge(moduleName, body);

    await this.moduleNameRepo.save(merge);

    return merge;
  }

  public async delete(id: string) {
    const moduleName = await this.moduleNameRepo.findOne({
      where: { id },
    });

    if (!moduleName) {
      throw new AppError('uModuleName não encontrado');
    }

    await this.moduleNameRepo.softDelete(id);

    return { ok: 'ok' };
  }
}

export default uModuleNameService;
